# Discription:

Some pairs of directed graphs have special homomorphisms, called right-resolving homomorphism or simply right resolver, between them. Some of these right-resolving homomorphisms are synchronizing. This project tests a conjecture that says that every strongly connected graph has a synchronizing right-resolving homomorphism onto a particular right-resoving factor - namely its maximal "bunchy" right-resolving factor.

The idea is as follows:
 - Generate random right-resolving extensions of given graph (usually one that is minimal under right resolvers).
 - For each generated graph G:
      - Construct the maximal buchy right resolving factor B(G) of G
      - Generate random right resolvers from G to B(G)
      - Construct the fiber product of these right resolvers with themselves, and use this to determine which right resolvers are synchronizing
      - Calculate the proportion of right resolvers that are synchronizing
 - Output data on the generated graphs and the proportion of right resolvers that are synchronizing

If the conjecture is true, the synchronizing proportion should be positive for all graphs. Even if all graphs are found to have some synchronizers (ie. no counterexample is found), the data generated by these tests provides usefull infonation about the synchronizing properties of graphs (eg. which graphs have many synchronizers, which graphs only have a few, etc.)

A graph is represented by the Graph object, which is initialized with an adjacency matrix. Graphs are only identified upto equality of adjacency matrices, and no attempt is made to determine the isomorphism class of graphs. 

Right resolvers are represented by the RightResolver object, which is initialized with a vertex map and an edge map. The vertex map is a binary matrix indexed by the vertex number of vertices in the domain and range graphs. The edge map is a five dimensional array, where the the two dimensional array given by specifying the first three coordinates represents the preimage of the corresponding edge in the range graph.

Fiber products are represented by the FiberProduct object, which is initialized with the right resolvers that it is the product of. These right resolvers must have the same range graph. A function constructs the graph of the the fiber product (which is a Graph object). The fiber product takes pairs of verticies in the domain graph for its vertex set, and adds an edge between two pairs of vertices if the first pair of vertices transitions to the second pair of vertices under the lifting of a single edge in the range graph. 

By constructing the fiber product of a right resolver with itself, we can determine the "stability congruence" of the right resolver in terms of the set of pairs of vertices that do not connect to the diagonal (the diagonal being pairs of the form (v,v) for some vertex v), and which pairs do not in turn connect to this set of pairs (this last set is the set of stable pairs). Taking the transitive closure gives the stability congruence, and the original right resolver is synchronizing iff each equivalence class of the stability congruence is an entire fiber of the vertex map of the right resolver.

# Usage:

Use the function testGraphsByM_G(M_G,n,numGraphs, trials, byQuotient = False, maxTries = 1000) to run the testing procedure. 

This will test "numGraphs" (dtype = int) randomly generated right resolving extensions of the graph "M_G" (dtype = Graph), where each externsion has "n" (dtype = int) vertices. "trials" (dtype = int) is the number of time-until-first-success trials that will be conducted when calculating the proportion of synchronizers for each graph. If set to True, "byQuotient" makes the random right resolver generating function use the vertex map given by a cannonical construction of the maximal bunchy factor. This improves efficiency. "maxTries" is the maximum number of right resolvers that will be tried in the time-until-first-success trials.

Data generated by this test is stored in a .pkl file. The functions of the form *CSV (eg. gernerateProbHistCSV) export this data as a .csv file for further analysis.

